Respuestas Laboratorio 4:
Integrantes: Amalia Alfonso - Daniel Rosales

PARTE 1.1:
1. Execute and check how the program works, Execute jVisualVM and inspect the CPU use of the corresponding process.
What is the reason of this CPU consumption?
What is the class responsable of that consump?

Este consumo se genera porque el Consumer mientras espera recursos no hace nada más hasta que el producer agregue datos a la cola, es decir que se queda en una espera activa. No se están usando los recursos correctamente,  por eso la clase responsable de ese alto consumo de CPU es la clase Consumer.

PARTE 2:
2. Compruebe el código e identifique cómo se implementó la funcionalidad indicada. Dado el propósito del juego, un invariante debe ser que la suma de los puntos de vida de todos los jugadores sea siempre la misma. (Por supuesto, en un momento en el que no se está realizando una operación de aumento / reducción de tiempo) . Para ese caso, para los jugadores N, ¿cuál debería ser ese valor?
> En ese caso, el valor debería ser el número de jugadores N por el valor de la salud predeterminada. Es decir N*DEFAULT_IMMORTAL_HEALTH=100N

3. Ejecute la aplicación y verifique cómo funciona la opción "pausar y verificar", ¿está satisfecho el invariante?
> No está satisfecho el invariante porque no está deteniendo la ejecución de los inmortales. Además, hay datos corruptos porque no se están alterando correctamente los datos, dado que cualquier inmortal puede aumentar o disminuir su vida al tiempo. También se evidencia una condición de carrera porque al atacar aleatoriamente a cualquier inmortal, puede ocurrir que dos de ellos ataquen a un mismo objetivo (otro inmortal).

5. Verifica de nuevo la funcionalidad haciendo clic muchas veces. ¿Se satisface el invariante?
> No se satisface el invariante porque aún no se ha tratado la condición de carrera que existe en el momento en que dos inmortales se atacan al mismo tiempo.

6. Identificar posibles regiones críticas con respecto a la lucha de los inmortales. Implementar una estrategia de bloqueo para evitar las condiciones de la carrera. Recuerde que si necesita usar dos o más 'bloqueos' simultáneamente, puede usar bloques sincronizados anidados.
> La región crítica se presenta cuando dos inmortales se atacan entre sí al mismo tiempo, porque se suma y resta a su salud al mismo tiempo. En el código, se presenta en el método fight en donde se cambian la salud de cada hilo. Si se atacan mutuamente, deben ser sincronizados para que  los recursos no se alteren corruptamente y solo se puedan alterar por un hilo, hasta que el lock indique que el recurso está desbloqueado y otro hilo puede acceder a él.

7. Después de implementar su estrategia. Ejecuta el programa y presta atención si se detiene. En ese caso, use los programas jps y jstacks para identificar por qué el programa detiene su ejecución.
> En efecto, al ejecutar varias veces se detiene el programa y no continúa mostrando cambios. Esto debe a un deadlock el cual es causado porque los dos inmortales (hilos) se bloquean para siempre, ya que uno está a la espera del otro. Como ambos pueden atacarse, cada uno está necesitando los mismos recursos y en este caso los está  obteniendo en diferente orden.

8. Piense en una estrategia para resolver el problema identificado (puede volver a consultar las 206 y 207 páginas de la "Concurrencia de Java en la práctica")
> Para solucionar el problema se debe mantener un orden a la hora de la sincronización, para esto se usa el método hasCode de cada hilo, ya que así se podrá conocer el valor entero, generado por un algoritmo de hashing, el cual es único para cada objeto. También se puede usar el método  getId() de cada hilo, el cual devuelve un identificador asignado a cada uno en el momento de su creación. Con éstos valores se pueden sincronizar los hilos siempre en el mismo.

9. Cuando haya resuelto el problema, verifique que el programa continúe trabajando con coherencia al ejecutar 100,1000 o 10000 inmortales. Si con gran cantidad de inmortales vuelves a romper el invariante. Tienes que analizarlo de nuevo (paso 4)

> Al momento de ejecutar, el invariante aún no está satisfecho, y es porque se deben actualizar las llamadas de regreso después de terminar las dos sincronizaciones.
Una vez cambiado el momento en que se actualiza CallBack, se puede ver que el invariante se mantiene igual.

10. Un elemento molesto de la simulación, que es cierto punto de la misma, hay pocos inmortales vivos que luchan con inmortales muertos. Es necesario eliminar a los inmortales muertos en la simulación cuando están muriendo, para eso:

Analizando cómo funciona la simulación. Esto podría crear una condición de carrera? Implemente la funcionalidad, ejecute la simulación y observe qué problema se presenta cuando hay muchos inmortales. Escriba algunas conclusiones en el archivo Answers.txt

Resuelva el problema identificado anteriormente sin uso Sincronización, ya que la secuencia del proceso haría la simulación extremadamente lenta.

> Al resolver el problema no presentamos dificultades, y se puede evidenciar su correcto funcionamiento, porque al ejecutar el programa se puede ver como disminuyen los inmortales a medida que van muriendo. Cuando son muchos inmortales toma mucho tiempo porque la salud total, está dividida entre unos pocos, entonces acabar con la de alguno es más complicado. Cuando son pocos se puede ver rápidamente que finalmente solo quedan dos inmortales azacanasen infinitamente.

